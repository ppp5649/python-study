### 바인딩(Biding) ###
# 파이썬에서 =는 바인딩을 의미합니다. 여기서 바인딩이란 변수가 어떤 값을 가리키는 것을 의미합니다.

a = 3

# =이 있으면 파이썬 인터프리터는 먼저 오른쪽을 해석합니다. 따라서 위 코드가 실행되면 먼저 3이라는 정수 타입의 객체가 메모리에 할당됩니다.
# 그 다음 메모리에 할당된 객체의 주소를 a라는 변수가 가리킵니다. 이를 파이썬에서는 바인딩이라고 부릅니다.
# 3이라는 객체가 할당된 주소를 확인하려면 id 내장함수를 사용합니다. 객체 생성 및 바인딩을 그림으로 표현하면 다음과 같습니다.

print(id(a))

### 레퍼런스 카운트(Reference Count) ###
# 파이썬에서 어떤 값은 어떤 타입의 객체입니다.
# 예를 들어 int 타입의 객체, float 타입의 객체, str 타입의 객체를 예를 들 수 있습니다.
# 다음 코드에서 a라는 변수는 int 타입의 객체 3을 바인딩합니다. int 타입의 객체 3이 메모리에 할당되고 이를 변수 a가 바인딩합니다.
# 변수가 어떤 객체를 바인딩하면 객체의 레퍼런스 카운트 값이 증가합니다.

import sys

print(sys.getrefcount(a))

# 위 코드를 실행해봅시다.
# a가 바인딩하는 객체인 '3'의 레퍼런스 카운트가 화면에 출력됩니다.
# 꽤 큰 값이 나오는데 이는 이미 파이썬 인터프리터가 실행될 때 내부에서 3이라는 값을 여러번 참조했기 때문입니다.

# 다음과 같이 b와 c라는 변수도 3을 바인딩해봅시다.
# 3이라는 객체 입장에서 생각해보면 자기 자신을 b와 c라는 새로운 변수가 바인딩하는 것이 되며
# 이 경우 객체 내부에 저장된 레퍼런스 카운트 값이 증가합니다.
# 3에 대한 레퍼런스 카운트 값을 출력해보면 44로 42에서 2만큼 증가된 것을 확인할 수 있습니다.

b = 3
c = 3
print(sys.getrefcount(3))

# 이번에는 리스트 객체에 대해서 동일하게 코드를 실행해 봅시다.
# 출력 값을 살펴보면 2가 나오는 것을 확인할 수 있습니다.
# sys 모듈의 getrefcount 함수가 호출되면서 해당 객체를 참조하므로 1만큼 증가된 레퍼런스 카운트가 출력됩니다.
# 따라서 실제로는 [0, 1, 2]라는 리스트 객체에 대한 레퍼런스 카운트는 1이라고 생각하면 됩니다.

arr = [0, 1, 2, 3]
print(sys.getrefcount(arr))

### 레퍼런스 카운트와 Garbage Collection ###
# 파이썬에서 모든 값은 어떤 클래스의 인스턴스 입니다. 다른 말로는 이를 객체라고 부릅니다.
# 객체는 어떤 변수가 자신을 참조할 때 마다 레퍼런스 카운트를 증가시키고 참조가 해제되면 레퍼런스 카운트를 감소합니다.
# 객체의 레퍼런스 카운트가 0이 되면 파이썬 인터프리터 해당 객체에 대한 메모리 할당을 해제합니다.
# 이런 방식은 CPython의 가비지 콜렉션의 기본 메커니즘입니다.
# CPython은 여기에 추가로 세대별 가비지 컬렉션(General Garbage Collection)을 사용합니다.
